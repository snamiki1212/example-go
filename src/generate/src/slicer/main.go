package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"slices"
	"strings"
	"text/template"
)

const templatePath = "./accessor.tmpl"
const inputPath = "./src/core/domain/user/user.go"
const outputPath = "./src/core/domain/user/user.gen.go"
const inputFile = "user.go"
const outputFile = "user_gen.go"

const isDebug = true // TODO:

func main() {
	fmt.Println("this is slicer")
	excludeFields := []string{"Posts"}
	const entityName = "User"
	const sliceName = "Users"

	// args := os.Args

	// sliceName := "Users"

	// pwd
	pwd := getPWD()

	// Ast
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, pwd+"/"+inputFile, nil, parser.AllErrors)
	if err != nil {
		panic(err)
	}
	if isDebug {
		ast.Print(fset, node) // for debug
	}

	// get package name
	pkgName := node.Name.Name

	// from stg ast to own Fields
	var fields Fields
	{
		objs := node.Scope.Objects
		obj, ok := objs[entityName]
		if !ok {
			panic("not found entity")
		}

		fmt.Println(obj.Name)
		fmt.Println(obj.Kind)
		decl := obj.Decl
		fmt.Println(decl)

		entity, ok := decl.(*ast.TypeSpec)
		if !ok {
			panic("invalid decl")
		}
		fmt.Println(entity)
		ty := entity.Type

		// https://stackoverflow.com/questions/20234342/get-a-simple-string-representation-of-a-struct-field-s-type
		sty, ok := ty.(*ast.StructType)
		if !ok {
			panic("invalid type")
		}
		rawFields := sty.Fields.List
		fmt.Println(rawFields)

		fields = newFields(rawFields)
		fmt.Println(fields)
		fields = fields.exclude(excludeFields)
		fmt.Println(fields)
	}

	// Output file
	output, err := os.Create(pwd + "/" + outputFile)
	if err != nil {
		panic(err)
	}
	defer output.Close()
	// append
	_, err = output.WriteString("// Code generated by go generate DO NOT EDIT.\n\n")
	if err != nil {
		panic(err)
	}
	_, err = output.WriteString("package " + pkgName + "\n\n")
	if err != nil {
		panic(err)
	}

	// append templates
	{
		tp, err := template.ParseFiles(templatePath)
		if err != nil {
			panic(err)
		}
		for _, f := range fields {
			data := map[string]string{
				"Slices": sliceName,
				"Method": NewMethodName(f.Name),
				"Type":   f.Type,
				"Field":  f.Name,
			}
			err = tp.Execute(output, data)
			if err != nil {
				panic(err)
			}
		}
	}
	// DEBUG
	fmt.Println(":D")

}

func getPWD() string {
	if isDebug {
		return "/Users/snamiki1212/ghq/github.com/snamiki1212/example-go/src/generate/src/core/domain/user"
	}
	pwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Println(pwd)
	return pwd
}

type (
	Fields []Field
	Field  struct {
		Name string
		Type string
	}
)

func newField(raw *ast.Field) Field {
	name := raw.Names[0].Name
	typeName := func() string {
		switch tt := raw.Type.(type) {
		case *ast.Ident:
			return tt.Name
		case *ast.StarExpr:
			return "*" + tt.X.(*ast.Ident).Name
		}
		return "<invalid-type-name>"
	}()
	return Field{
		Name: name,
		Type: typeName,
	}
}

func newFields(raws []*ast.Field) Fields {
	fields := make(Fields, 0, len(raws))
	for _, raw := range raws {
		fields = append(fields, newField(raw))
	}
	return fields
}

func (fs Fields) exclude(targets []string) Fields {
	return slices.DeleteFunc(fs, func(f Field) bool {
		return slices.Contains(targets, f.Name)
	})
}

func NewMethodName(fieldName string) string { return fieldName + "s" }

type Arg struct {
	// Target entity name
	Entity string

	// Target slice name
	Slice string

	// Exclude field names
	Excludes []string
}

func newArg(rawArgs []string) Arg {
	pattern := `-(\w+)=(\w+)`

	arg := Arg{}
	for _, rawarg := range rawArgs {
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(rawarg)
		if len(matches) != 2 {
			panic("invalid arg: " + rawarg)
		}
		key, val := matches[1], matches[2]
		switch key {
		case "entity":
			arg.Entity = val
		case "slice":
			arg.Slice = val
		case "exclude":
			arg.Excludes = strings.Split(val, ",")
		}
	}
	return arg
}

func (a Arg) validate() bool {
	if a.Entity == "" {
		return false
	}
	if a.Slice == "" {
		return false
	}
	return true
}
